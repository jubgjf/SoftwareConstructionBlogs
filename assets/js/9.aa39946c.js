(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{372:function(t,a,s){"use strict";s.r(a);var e=s(18),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"软件测试与测试优先的编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#软件测试与测试优先的编程"}},[t._v("#")]),t._v(" 软件测试与测试优先的编程")]),t._v(" "),s("h2",{attrs:{id:"测试介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试介绍"}},[t._v("#")]),t._v(" 测试介绍")]),t._v(" "),s("h3",{attrs:{id:"验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[t._v("#")]),t._v(" 验证")]),t._v(" "),s("p",[t._v("测试是验证的一种，验证包括：")]),t._v(" "),s("ol",[s("li",[t._v("形式推理：理论证明正确性")]),t._v(" "),s("li",[t._v("代码审查：别人查自己的代码")]),t._v(" "),s("li",[t._v("测试")])]),t._v(" "),s("h3",{attrs:{id:"测试目的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试目的"}},[t._v("#")]),t._v(" 测试目的")]),t._v(" "),s("p",[t._v("残留缺陷率 = 软件中的 bug 数 / 1000 行")]),t._v(" "),s("ul",[s("li",[t._v("1 - 10 defects/kloc: 典型工业软件")]),t._v(" "),s("li",[t._v("0.1 - 1 defects/kloc: 高质量软件，如 "),s("code",[t._v("Java")]),t._v(" 库")]),t._v(" "),s("li",[t._v("0.01 - 0.1 defects/kloc: NASA 级别")])]),t._v(" "),s("h3",{attrs:{id:"测试等级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试等级"}},[t._v("#")]),t._v(" 测试等级")]),t._v(" "),s("ol",[s("li",[t._v("单元测试：函数层级上")]),t._v(" "),s("li",[t._v("集成测试：多个类/包/组件/子系统层级上")]),t._v(" "),s("li",[t._v("系统测试：整个系统层级上")]),t._v(" "),s("li",[t._v("验收测试：层级最高")])]),t._v(" "),s("h3",{attrs:{id:"静态-动态测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态-动态测试"}},[t._v("#")]),t._v(" 静态/动态测试")]),t._v(" "),s("ul",[s("li",[t._v("静态测试：不运行代码，靠眼睛看。如 reviews, walkthroughs, inspections")]),t._v(" "),s("li",[t._v("动态测试：用测试用例运行")])]),t._v(" "),s("h3",{attrs:{id:"白盒测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#白盒测试"}},[t._v("#")]),t._v(" 白盒测试")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("黑盒测试")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("白盒测试")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("不考虑内部实现，对程序外部表现的行为进行测试")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("考虑内部实现细节，对程序内部代码结构测试")])])])]),t._v(" "),s("h2",{attrs:{id:"测试优先的编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试优先的编程"}},[t._v("#")]),t._v(" 测试优先的编程")]),t._v(" "),s("h3",{attrs:{id:"步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[t._v("#")]),t._v(" 步骤")]),t._v(" "),s("ol",[s("li",[t._v("先写 spec")]),t._v(" "),s("li",[t._v("再写符合 spec 的测试用例")]),t._v(" "),s("li",[t._v("最后写代码。执行测试，有问题再改")])]),t._v(" "),s("h3",{attrs:{id:"tdd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tdd"}},[t._v("#")]),t._v(" TDD")]),t._v(" "),s("p",[t._v("TDD (Test-driven development)：测试驱动开发")]),t._v(" "),s("h2",{attrs:{id:"划分测试用例区域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#划分测试用例区域"}},[t._v("#")]),t._v(" 划分测试用例区域")]),t._v(" "),s("h3",{attrs:{id:"等价类划分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#等价类划分"}},[t._v("#")]),t._v(" 等价类划分")]),t._v(" "),s("p",[t._v("将被测函数的输入域划分为等价类，从中导出测试用例")]),t._v(" "),s("p",[t._v("基于假设：相似的输入会展示相似的行为")]),t._v(" "),s("h3",{attrs:{id:"边界值分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#边界值分析"}},[t._v("#")]),t._v(" 边界值分析")]),t._v(" "),s("p",[t._v("大量的错误发生在输入域的边界而非中央")]),t._v(" "),s("p",[t._v("合理的测试用例分布：")]),t._v(" "),s("ol",[s("li",[t._v("略低于最小值")]),t._v(" "),s("li",[t._v("最小值")]),t._v(" "),s("li",[t._v("略高于最小值")]),t._v(" "),s("li",[t._v("正常值")]),t._v(" "),s("li",[t._v("略低于最大值")]),t._v(" "),s("li",[t._v("最大值")]),t._v(" "),s("li",[t._v("略高于最大值")])]),t._v(" "),s("p",[s("img",{attrs:{src:"images/ch2_boundary_test.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"覆盖率测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#覆盖率测试"}},[t._v("#")]),t._v(" 覆盖率测试")]),t._v(" "),s("h3",{attrs:{id:"覆盖度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#覆盖度"}},[t._v("#")]),t._v(" 覆盖度")]),t._v(" "),s("ol",[s("li",[t._v("函数覆盖")]),t._v(" "),s("li",[t._v("语句覆盖")]),t._v(" "),s("li",[t._v("分支覆盖："),s("code",[t._v("if")]),t._v(", "),s("code",[t._v("while")]),t._v(", "),s("code",[t._v("switch")]),t._v(", "),s("code",[t._v("for")]),t._v(" 都用 "),s("code",[t._v("true")]),t._v(" 或 "),s("code",[t._v("false")]),t._v(" 测试")]),t._v(" "),s("li",[t._v("条件覆盖："),s("code",[t._v("if")]),t._v(", "),s("code",[t._v("while")]),t._v(", "),s("code",[t._v("switch")]),t._v(", "),s("code",[t._v("for")]),t._v(" 的每一种情况都覆盖")]),t._v(" "),s("li",[t._v("路径覆盖：在程序控制流图的基础上，通过分析控制结构的环路复杂性，导出基本可执行路径集合，设计测试用例的方法。 该方法把覆盖的路径数压缩到一定限度内，程序中的循环体最多只执行一次。 设计出的测试用例要保证在测试中，程序的每一个可执行语句至少要执行一次。")])]),t._v(" "),s("h3",{attrs:{id:"测试效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试效果"}},[t._v("#")]),t._v(" 测试效果")]),t._v(" "),s("ul",[s("li",[t._v("测试效果：路径覆盖 > 分支覆盖 > 语句覆盖")]),t._v(" "),s("li",[t._v("测试难度：路径覆盖 > 分支覆盖 > 语句覆盖")]),t._v(" "),s("li",[t._v("覆盖率要求\n"),s("ul",[s("li",[t._v("工业上通常要求 100% 语句覆盖，除非有极少见的不可达语句")]),t._v(" "),s("li",[t._v("100% 的分支覆盖更加艰难")]),t._v(" "),s("li",[t._v("100% 的路径覆盖几乎不可能")])])])]),t._v(" "),s("h2",{attrs:{id:"自动化测试和回归测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动化测试和回归测试"}},[t._v("#")]),t._v(" 自动化测试和回归测试")]),t._v(" "),s("h3",{attrs:{id:"自动化测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动化测试"}},[t._v("#")]),t._v(" 自动化测试")]),t._v(" "),s("p",[t._v("测试驱动：能够进行自动化测试的代码")]),t._v(" "),s("p",[t._v("自动调用被测函数、自动判定测试结果、自动计算覆盖度")]),t._v(" "),s("p",[t._v("并非自动生成测试用例。测试用例还需要我们自己编写")]),t._v(" "),s("h3",{attrs:{id:"回归测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回归测试"}},[t._v("#")]),t._v(" 回归测试")]),t._v(" "),s("p",[t._v("一旦程序被修改，重新执行之前的所有测试")]),t._v(" "),s("p",[t._v("一旦修复一个 bug，将触发 bug 的输入加入到测试")]),t._v(" "),s("h2",{attrs:{id:"编写测试策略文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编写测试策略文档"}},[t._v("#")]),t._v(" 编写测试策略文档")]),t._v(" "),s("p",[t._v("测试策略")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n * Testing strategy\n * \n * Partition the inputs as follows:\n * text.length():           0, 1, > 1\n * start:                   0, 1, text.length()\n *                          text.length() - 1,\n *                          1 < start < text.length(),\n * text.length() - start:   0, 1, even > 1, odd > 1\n * \n * Include even- and odd-length reversals because\n * only odd has a middle element that doesn't move.\n * \n * Exhaustive Cartesian coverage of partitions.\n */")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("p",[t._v("测试方法注释")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// covers test.length() = 0,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        start = 0 = text.length(),")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        text.length()-start = 0")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Test")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("testEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("assertEquals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverseEnd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])])])}),[],!1,null,null,null);a.default=v.exports}}]);